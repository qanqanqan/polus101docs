# Краткая история использования серверов
Вам базово нужно знать историю развития серверных технологий для понимания важности, а так же общего понимания логики актуальных серверных решений. 

## Доисторические времена
В доисторические времена, если вы хотели запустить свой сайт на сервере, вам было необходимо сервер арендовать. Буквально арендовать в пользование физический сервер - целую коробку в дата центре.

<p align="center">
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Docker/img/phis_1.png" style="width:60%"/>
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Docker/img/phis_2.png" style="width:60%"/>
</p>

Это порождало много сложностей. 
- Во первых, физические сервера (буквально коробки) имели излишнюю мощность, которая могла быть вам не нужна. Если у вас обычный небольшой сайтик или даже корпоративное приложения, вам было ни к чему арендовать столько мощностей, сколько выдавал физический сервер, так как ваше ПО не использовало бы всю его мощность
- Во вторых, активность на вашем сайте или сервисе могла периодически падать. Например, ночью. При этом сервер простаивал почти впустую, но деньги вы все равно за него платили


## Менее доисторические времена
`1990-2000 года`: в это время решением проблемы стала технология `виртуализации`. 
По сути своей технология виртуалзация позволяла на одной физической машине (сервере) запускать сразу несколько операционных систем (прямо как современная программа `Virtual Box`)

<p align="center">
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Docker/img/virt_1.png" style="width:60%"/>
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Docker/img/virt_2.png" style="width:60%"/>
</p>

Это существенно удешевило использование серверов. Теперь заказчик мог сам выбрать, какой объем ресурсов (оперативной памяти, места на жестком диске и кол-ва ядер процессора) ему необходимо.

Теперь на одном физическом сервере могли находиться приложения, сайты и сервисы разных клиентов, при этом не пересекаясь между собой

Но, проблемы все еще были:
- Виртуальная машина (ОС внутри другой ОС) - штука тяжеловесная и сама по себе требующая много ресурсов. Если вы пробовали работать с VirtualBox, то вы наверняка сталкивались с этим
- Арендуя виртуальную машину, клиент мог запускать на ней несколько сервисов (сайтов или приложений, например), которые были не изолированы друг от друга и могли мешать работе друг друга

## Наше время
Начала разрабатываться технология контейнеризации еще в `2000 году`, но приняла привычный нам вид только к `2013 году`. Именно тогда появился `Docker`!

Технология контейнеризации работает поверх виртуализации. У вас все еще есть виртуальная машина на физической машине, но все ваши сервисы работают раздельно и изолированно друг от друга

Работает это так - для каждого сервиса запускается небольшой образ виртуальной машины - *контейнер* (да, получается, виртуалка внутри виртуалки). Но контейнер отличается от полноценной виртуальной машины тем, что все контейнеры используют одно ядро ОС. 

Это не полноценная виртуальная операционная система. В ней оставили все только самое необходимое для запуска и работы сервисов, отбросив все тяжелое. К тому же все контейнеры пользуются одним ядром, так что не нужно отдельно эмулировать ядра для каждого сервиса

<p align="center">
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Docker/img/cont_1.png" style="width:60%"/>
<img src="https://github.com/Polus101/resources/blob/master/Encyclopedia/Docker/img/cont_2.png" style="width:60%"/>
</p>

У докера все еще есть несколько минусов:
- При большом количестве сервисов, которые должны работать вместе и передавать данные между собой, возникают сложности. Они ведь работают изолированно - в этом и смысл. Но что, если они должны общаться, выполняя одну задачу?
- Docker используется не только в серверах, но и при разработке программ. Но он все еще требует дополнительных ресурсов компьютера, которые есть все еще не у всех. Поэтому применять его при разработке софта не для всех удобно


### Kubernetes
Это технология оркестрации - Kubernetes позволяет контролировать и налаживать связи между контейнерами. Это удобно, если у вас более 100 сервисов, работающих в единой системе, как например у Яндекса или Сбера. Но это уже не задача программиста, а задача DevOps инженера. 

Хотя знать хотя бы о ее существовании вам все равно надо)
