# Классы, методы, атрибуты(поля)

Пришло время узнать о методах реализации классов, полей(атрибутов) и методов

## Оглавление
- [Создание простого класса](#создание-простого-класса)
- [Создание экземпляра класса - объекта](#создание-экземпляра-класса---объекта)
- [Метод для инициализации полей объектов](#метод-для-инициализации-полей-объектов)
- [Атрибуты(поля) объектов](#атрибутыполя-объектов)
- [Методы для работы с полями объектов](#методы-для-работы-с-полями-объектов)
- [Результат](#результат)

## Создание простого класса

В **Python** конструкция объявления класса во многом схожа с конструкцией объявления функции - начинается с ключевого слова, после которого идет название. Для классов таким ключевым словом является ***"class"***:

```python
class MyClass:
    ...
```

Среди программистов принято называть классы с большой буквы - это позволяет легче распознать лексемы в коде, относящиеся к различным объектам кода (функции, переменные, классы)

Порой после названия класса могут идти скобки - это необходимо для ***наследования***, важного аспекта работы с классами. О наследовании подробнее можно узнать тут: **[Принципы ООП](oop-principles.md)**


## Создание экземпляра класса - объекта

После создания описания класса(ключевого слова **class**) возможно создание первых объектов класса. Тем не менее, пока такой класс не будет предоставлять какого-либо функционала кроме создания объекта.

Создание экземпляра класса(объекта) происходит при вызове класса и сохранении возвращаемого значения в переменную:

```python
class Myclass:
    pass


myObject = Myclass()
```

После вызова класса(часто это называют вызовом **конструктора** класса) происходит создание экземпляра класса(объекта) и сохранение его в переменную.

Если затем вывести эту переменную на экран, то мы получим информацию о созданном объекте - его причастность к классу, а так же то, в каком файле был описан класс:

```python
print(myObject)
# <__main__.Myclass object at 0x00000235ED43BBD0>
```

`__main__` говорит о том, что класс описан в текущем файле, а `Myclass` через точку сообщает название класса.


## Метод для инициализации объектов

После объявления класса необходимо создать его первый, базовый метод - это метод `__init__()`. Любой новый метод прописывается внутри своего класса, с отступом.

```python
class Myclass:
    def __init__(self):
        ...
```

Данный метод прописывается с **дандерами**(двумя подчеркиваниями) в начале и конце - данное написание выделяет стандартные методы классов - еще их часто называют ***магическими*** или ***дандер методами***, о них можно узнать тут: **[Магические/дандер методы](magic-methods.md)**.

Этот метод является особенным - его не надо вызывать отдельно, поскольку это происходит автоматически при создании нового объекта класса.

Наличие `__init__()` метода - необязательный критерий для создания класса, но он необходим для присвоения объекту атрибутов(полей) при его создании.

Параметр ***"self"***, передаваемый в метод, обозначает непосредственном сам объект, к которому применяется данный метод. Это необходимо для доступа ко всем атрибутам данного объекта - их изменению, созданию и так далее. Аргумент **"self"** передается автоматически, при создании *экземпляра класса*(объекта) значение в этот аргумент передавать не нужно.


## Атрибуты(поля) объектов

Как говорилось ранее, метод `__init__()` необходим для объявления и инициализации атрибутов создаваемых объектов при создании объекта. Чтобы это произошло необходимо в данном методе прописать непосредственно сами атрибуты.

Если атрибут должен передаваться с аргументом конструктору класса, то в скобки методу добавляются непосредственно данные аргументы для их дальнейшего сохранения в поля объекта. Но можно также обойтись без передачи значений в виде аргументов конструктора класса - в данном случае при создании объекта его атрибуту будет присвоено стандартное, базовое значение.

```python
class Myclass:
    def __init__(self, argument1, argument2):
        self.variable1 = argument1
        self.variable2 = argument2
        
        self.variable3 = 0
        self.variable4 = 'Jeff'
```

В примере выше в конструктор класса передаются три аргумента - стандартный **"self"**, а также два наших аргумента - **"argument1"**, **"argument2"**.

Также в примере в конструкторе класса создается 4 атрибута(поля) для будущего *экземпляра класса*(объекта) - **"variable1"**, **"variable2"**, **"variable3"**, **"variable4"**. Заметьте, что данные атрибуты "применяются" к переменной аргумента **"self"**. Вспоминаем, что в данный аргумент автоматически передается непосредственно сам объект - тут же становится понятно, что мы таким образом производим модификации(*создание, изменение, удаление*) его атрибутов, обращаясь к нему через *точку*. Теперь о самих атрибутах(полях).

Атрибуты **"variable1"**, **"variable2"** инициализируются при помощи переданных в конструктор класса аргументов **"argument1"**, **"argument2"**. Иными словами, в них записываются те значения, что мы укажем сами при создании экземпляра класса.

Атрибуты **"variable3"**, **"variable4"** инициализируются теми данными, которые уже были указаны в конструкторе класса, изменить их при создании экземпляра класса нельзя. К тому же, если создать два разных объекта, то конкретно эти атрибуты изначально у них будут равны.

Также стоит уточнить, что в данные атрибуты можно сохранять любые значения - ведь это обычные переменные, только они принадлежат какому-то объекту. Возможна реализация атрибутов через экземпляры других классов - таким образом атрибутом объекта текущего класса будет объект другого класса.

```python
class Secondclass:
    ...

class Myclass:
    def __init__(self, argument1):
        self.variable1 = argument1
        self.variable2 = Secondclass()
```

В этом случае получить доступ к атрибутам объекта класса **Secondclass** возможно через атрибут объекта класса **Myclass**. Произошла вложенность объектов. 

Мы вольны менять значения атрибутов объекта после его создания, присваивать в него новые значения. Для этого не требуется дополнительных методов, достаточно лишь обратиться к самому атрибуту объекта напрямую:

```python
class Myclass:
    def __init__(self, argument1, argument2):
        self.variable1 = argument1
        self.variable2 = argument2


myObject = Myclass(33, 'abraham lincoln')
print(myObject.variable1, myObject.variable2)
# Выводится:
# 33 abraham lincoln

myObject.variable1 = 51
myObject.variable2 = 'boris yeltsin'
print(myObject.variable1, myObject.variable2)
# Выводится:
# 51 boris yeltsin
```


## Методы для работы с полями объектов

Несмотря на наличие возможности управлять атрибутами класса как мы захотим без наличия методов, последние, в свою очередь, позволяют установить четкие рамки для других разработчиков при работе с нашим классом. Методы явно указывают на то, как именно нужно пользоваться нашим классом, а если мы работаем над нашим проектом в одиночестве, то не позволит нам создать спагетти-код, который запутает уже нас. *Для этого и нужны методы.*

По сути создание методов класса это один из элементов ***инкапсуляции***, подробнее об этом можно узнать тут - **[Принципы ООП](oop-principles.md)**.

Создание нового метода поисходит по аналогии с тем, как мы это делали с `__init__()` - внутри своего класса, с отступом. Например, если необходимо создать метод для отображения одного из атрибутов объекта, то сделать это можно так:

```python
class Myclass:
    ...

    def show_variable1(self):
        print(self.variable1)
```

В данном случае дандеры в начале и конце функции не нужны - данный метод не является **магическим** или стандартным, это просто функция, которая выводит на экран определенный атрибут объекта. Обратите внимание, здесь также применяется аргумент **"self"** - без его указания невозможно получить доступ к данным конкретного объекта, к которому применяется метод

А если, например, необходимо создать метод для редактирования элемента, то это сделать так же просто, как и метод для его отображения:

```python
class Myclass:
    ...

    def change_variable3(self):
        self.variable3 = self.variable3 + 100
```

Заметим, что возвращать значение в данном случае не нужно - изменение атрибута произойдет в любом случае, поскольку мы обращаемся непосредственно к объекту, пусть даже это происходит в функции

Но написание метода с возвратом значения так же возможно:

```python
class Myclass:
    ...

    def get_variable4(self):
        return self.variable4
```

Методы имеют ВСЕ свойства обычных функций, а значит в них можно делать все то же, что и с обычными функциями - рекурсии, вложенность, циклы, условия и так далее.


## Результат

Теперь применим все полученные знания на практике - создадим простой класс, отображающий информацию об ученике школы. Сделаем ему пару полей - для его имени, любимого школьного предмета и его оценкам, а так же сделаем пару методов - для отображения информации об ученике, для добавления новых оценок, а так же изменения любимого предмета.

1. Создаем новый класс.

    ```python
    class Student:
        ...
    ```

2. Создаем базовый метод для иницилизации атрибутов присоздании экземпляра класса. 

    ```python
    class Student:
        def __init__(self):
            ...
    ```

3. Объявляем все необходимые поля, инициализируем их через аргументы метода `__init__()`.

    ```python
    class Student:
        def __init__(self, name, grades, favourite_class):
            self.name = name
            self.favourite_class = favourite_class
            self.grades = grades
    ```

4. Создадаем методы для отображения информации об ученике и его любимом предмете, а так же добавлении новых оценок и изменения любимого предмета.

    ```python
    class Student:
        def __init__(self, name, grades, favourite_class):
            self.name = name
            self.favourite_class = favourite_class
            self.grades = grades


        def show_student_info(self):
            print(f"""\
            Имя: {self.name}
            Любимый предмет: {self.favourite_class}""")

        
        def add_grade(self, grade):
            self.grades.append(grade)


        def change_favourite_class(self, new_fvrt_class):
            self.favourite_class = new_fvrt_class
    ```

Получился полноценный класс с небольшим функционалом. Теперь можно создавать экземпляры класса и тестировать его.

```python
class Student:
    ...


first_student = Student('Alesha', [2, 2, 1, 2, 2], 'fizra')
second_student = Student('Katya', [5, 5, 4, 5], 'maths')

first_student.show_student_info()
# Вывод:
# Имя: Alesha
# Любимый предмет: fizra
second_student.show_student_info()
# Вывод:
# Имя: Katya
# Любимый предмет: maths
```

В примере увидим то, что у разных объектов разные значения атрибутов, а так же то, что к разным объектам одного и того же класса можно применять одни и те же методы.