# Основные принципы ООП

Структурирование программных объектов на основе ООП опирается на несколько основных **принципов**, соблюдение которых позволяет создать грамотную и продуманную объектную модель. Без соблюдения этих **принципов** написание ООП-кода происходит медленно, запутанно и тяжело. Поэтому важно их понимание хотя бы на базовом уровне и их соблюдение при написании собственных объектных моделей. Разберем все на примере.

Начало работы с ООП происходит с анализа прикладной области - того, что необходимо представить в системы отношения объектов. Вспомним, что ООП хорош в том, чтобы представить в виде программного кода объекты из реальной жизни и попробуем это сделать собственноручно.

Например, поставлена задача по проектированию системы велосипеда - его базовых функций и параметров. Учитывая весь набор механизмов, это сложная задача для функционального программирования, но простая для ООП - достаточно разбить исследуемую систему на различные объекты и проанализировать их взаимодействие друг с другом!

___
### <u><b>Принцип №1 - Абстракция</b></u>

У велосипеда есть колеса, рама, у колес есть спицы, обода, покрышки, к раме крепится руль, кривошипная система, переключатели передач... Слишком много объектов...

**Абстракцией** в ООП называется методика использования только тех параметров/данных/характеристик объекта, которые позволяют с достаточной точностью понять, что за объект перед нами представлен и позволяют его отличить от сторонних схожих объектов.

В случае с велосипедом нет надобности в описании каждого его винтика - достаточно указать марку, модель и прочие общие характеристики, которые являются наиболее важными - размер рамы, размер колес и количество скоростей.

```python
class Bicycle:
    def __init__(self, brand, model, size, wheel_size, speed_amount):
        self.brand = brand
        self.model = model
        self.size = size
        self.wheel_size = wheel_size
        self.speed_amount = speed_amount
```

Данный набор полей достаточен для того чтобы отделить один экземпляр от другого с достаточной точностью.

Примерами плохой абстракции могут послужить наличие чрезмерного числа атрибутов или наоборот их недостаточное количество. Если невозможно описать объект при помощи ограниченного числа полей, то стоит присмотреться к созданию дополнительной классовой абстракции одного из атрибутов объекта - в случае с велосипедом, если есть нужда в описании его трансмиссии, то возможно создание отдельного класса для этого объекта. Сам экземпляр класса трансмиссии при этом будет создаваться в одном из полей экземпляра класса велосипеда, тем самым, станет его атрибутом:

```python
class Transmission:
    def __init__(self):
        ...

class Bicycle:
    def __init__(self, brand, model, size, wheel_size, speed_amount):
        self.brand = brand
        self.model = model
        self.size = size
        self.wheel_size = wheel_size
        self.speed_amount = speed_amount
        self.transmission = Transmission()
```

В этом примере показана реализация поля *transmission* класса **Bicycle** через другой класс **Transmission**.

___
### <u><b>Принцип №2 - Инкапсуляция</b></u>

По мере создания класса нам захочется защитить некоторые поля объектов от их непредвиденных изменений пользователем. Так, например, если добавить к классу **Bicycle** поле для подсчета количества пройденных километров, то безопаснее было бы ограничить изменение данного атрибута напрямую и сделать для этого специальный набор методов.

**Инкапсуляцией** в ООП называется практика ограничения доступа к атрибутам экземпляров класса посредством запрета их прямого изменения без применения методологий описанного класса. **Инкапсуляция** необходима также для предотвращения доступа к атрибутам класса из стороннего класса.

Базовая **инкапсуляция** достигается засчет создания разных классов для репрезентации различных объектов, имеющих общие сходства. Но для запрета изменения атрибутов конкретного класса создание стороннего класса недостаточно, для этого возникает необходимость в "приватных" атрибутах. Создание таких атрибутов возможно при помощи дандеров в начале имени атрибута. После создания такого атрибута его изменение вне методов класса будет невозможно.

Рассмотрим вышестоящий пример на практике. Попробуем добавить новое поле для класса **Bicycle** и сделаем его приватным:

```python
class Bicycle:
    def __init__(self, ...):
        ...
        self.__odometer_reading = 0
```

Теперь попробуем изменить данный атрибут у экземпляра класса напрямую после его создания:

```python
class Bicycle:
    def __init__(self, ...):
        ...
        self.__odometer_reading = 0


myBike = Bicycle(...)
myBike.__odometer_reading = 100
print(myBike.__odometer_reading)
```

Несмотря на попытку изменения атрибута, его значение так и останется равным 0. Это происходит не только потому, что сам атрибут является "приватным", но и потому что при его получении напрямую, не важно, был ли он изменен корректно или нет, возвращенное значение всегда будет равно изначальному, прописанному в методе инициализации объекта данного класса. Для корректного отображения текущего состояния атрибута объекта необходимо написание дополнительного метода.

Если прописать метод для изменения атрибута и его отображения, тогда картина изменится:

```python
class Bicycle:
    def __init__(self, ...):
        ...
        self.__odometer_reading = 0

    def set_odometer_reading(self, value):
        self.__odometer_reading = value

    def show_odometer_reading(self):
        print(self.__odometer_reading)

myBike = Bicycle(...)
myBike.set_odometer_reading(100)
myBike.show_odometer_reading()

print(myBike.__odometer_reading)
```

В этом случае атрибут объекта myBike будет изменен и на экране отобразится его новое значение - 100.

Помимо "приватных" атрибутов также есть "приватные" методы классов. Создаются похожим образом - в начале наименования метода добавляется дандер. Такой метод нельзя вызвать извне класса, подобного действие приведет к возникновению ошибки AttributeError в котором будет написано, что вызываемого метода в классе нет.

"Приватные" методы также полезны при создании сложных систем классов и их взаимоотношений. Но стоит заметить, что **инкапсуляция** в Python весьма ограничена и при необходимости ее можно с легкостью обойти(пример можно найти в этом вопросе на StackOverflow - ["Why are Python's 'private' methods not actually private?"](https://stackoverflow.com/questions/70528/why-are-pythons-private-methods-not-actually-private)). 

Тем не менее, это важный инструмент при работе со множеством классов и одинаковых методов у **наследуемых** классов, речь о которых пойдет дальше.

___
### <u><b>Принцип №3 и №4 - Полиморфизм и Наследование</b></u>

Порой стандартных свойств класса недостаточно при описании различных объектов - поля класса соответствуют лишь общему или, в худшем случае, ограниченному числу объектов. При данном сценарии использовать класс для создания специфичных экземпляров невозможно, приходится создавать заново новый класс, хоть и перенимающий часть свойств, но так же имеющий специфику тех объектов, которые он представляет. Для упрощения работы при подобных сценариях существует принцип **наследования** классов, позволяющий использовать весь функционал "родительского" класса в "дочернем", при этом дополняя "дочерний" класс своими специфичными свойствами.

**Наследованием** в ООП называют принцип перенимания всего или части функционала одного класса другим. **Наследование** способствует отсутствию самоповторений кода и его надежной организации родственных связей между классами.

Наиболее простым примером применения **наследования** является разобщенность типов велосипедов. В предыдущей реализации класса **Bicycle** из примера не учитываются различные особенности разных моделей велосипедов - у некоторых из них колеса могут быть разного диаметра, у некоторых может отсутствовать трансмиссия, у каких-то есть амортизирующие элементы и так далее. При этом зачастую остальные свойства объекта сохраняются. Попробуем воплотить специфичный вид велосипеда через принцип **наследования** основных характеристик исходного класса **Bicycle** - создадим новый класс с наследованием от исходного.

**Наследование** классов начинается с создания "дочернего" класса после "родительского" и указания после его названия в скобках название наследуемого класса:

```python
class Bicycle:
    ...


class MulletBike(Bicycle):
    ...
```

После создания класса **MulletBike** в скобках был указан наследуемый класс **Bicycle** - таким образом было указано, что все методы и атрибуты класса **Bicycle** будут доступны классу **MulletBike**, а точнее его экземпляры будут иметь весь функционал наследуемого класса.

Для добавления специфичного функционала, в новом классе возможно создание своих методов и атрибутов. При этом описание метода инициализации полей класса будет несколько отличаться - поскольку мы хотим сохранить свойства исходного("родительского") класса, то необходимо это явно указать в методе `__init__` с применением фукнции ***super()***. Она позволяет получить доступ к методам наследуемого класса, возвращая его замещенный объект(еще его часто называют прокси-объектом):

```python
class Bicycle:
    ...


class MulletBike(Bicycle):
    def __init__(self, ..., first_wheel_size, second_wheel_size):
        super().__init__(self, ..., first_wheel_size, second_wheel_size)

        self.first_wheel_size = first_wheel_size
        self.second_wheel_size = second_wheel_size
```

Все те атрибуты, которые принимает класс **Bicycle** при создании своего экземпляра, необходимо так же указывать при создании экземпляра класса **MulletBike**. Добавление своих атрибутов в **MulletBike** происходит после вызова ***super()*** в `__init__`.

Теперь при создании экземпляра класса **MulletBike** мы сможем ему передать все те аргументы, которые передавали в класс **Bicycle**, но также еще имеем два дополнительных аргумента, эксклюзивные для данного класса. 

С методами все проще - если в "родительском" классе присутствует метод, конфликтующий со свойствами "дочернего" класса, то он должен быть переписан в "дочернем" классе:

```python
class Bicycle:
    ...

    def show_wheel_size(self):
        print(f'This bike has {self.wheel_size} inch wheels')


class MulletBike(Bicycle):
    def __init__(self, ..., first_wheel_size, second_wheel_size):
        super().__init__(self, ..., first_wheel_size, second_wheel_size)

        self.first_wheel_size = first_wheel_size
        self.second_wheel_size = second_wheel_size

    def show_wheel_size(self):
        print(f'This bike has {self.first_wheel_size} inch front wheel and {self.second_wheel_size} inch rear wheel')
```

Тогда при вызове метода **.show_wheel_size()** у экземпляра класса **MulletBike** будет выводиться именно то сообщение, которое прописано в этом классе. Сообщение из метода родительского класса выводиться на экран не будет. Эта особенность является представлением принципа **полиморфизма** в классах с наследованием, то есть наличию двух одинаковых по описанию методов, которые работают по-разному с представителями разных классов.

**Полиморфизм** в ООП представляет принцип применения одного метода для решения разных задач или в разных сценариях. **Полиморфизм** определяет способность одной функции(метода) работать с данными разных типов.

**Полиморфизм** тесно сопряжен с **наследованием**, потому они рассматриваются в текущем примере совместно.

### <u><b>Итог</b></u>

Зная определения и описания основных принципов ООП программисту проще освоить данную тематику. Придерживаясь всех вышеизложенных принципов, разработчик создает более универсальные и отказоустойчивые объектные интерфейсы, которые решают множество поставленных перед ним задач. 
